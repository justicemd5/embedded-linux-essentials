#!/bin/bash
#
# create_initramfs.sh - Create minimal BusyBox-based initramfs
#
# AUTO-GENERATED: This script was generated by AI. Verify before use.
#
# This script automates the creation of a minimal initramfs for embedded Linux.
# It downloads and builds BusyBox statically, creates the directory structure,
# and packages everything into a cpio.gz archive.
#
# PRIMARY TARGET: BeagleBone Black Rev. C (AM335x, ARM 32-bit)
#
# Usage: ./create_initramfs.sh [work_dir] [output_file]
#
# Example: ./create_initramfs.sh ./initramfs_work ./output/initramfs.cpio.gz
#
# Environment variables:
#   ARCH          - Target architecture (arm for BeagleBone Black)
#   CROSS_COMPILE - Cross-compiler prefix
#   BUSYBOX_VER   - BusyBox version to use
#

set -e

#==============================================================================
# Configuration (BeagleBone Black defaults)
#==============================================================================

WORK_DIR="${1:-$(pwd)/initramfs_work}"
OUTPUT="${2:-$(pwd)/initramfs.cpio.gz}"
ARCH="${ARCH:-arm}"                            # AM335x is ARM 32-bit
CROSS_COMPILE="${CROSS_COMPILE:-arm-linux-gnueabihf-}"
BUSYBOX_VER="${BUSYBOX_VER:-1.36.1}"
BUSYBOX_URL="https://busybox.net/downloads/busybox-${BUSYBOX_VER}.tar.bz2"

#==============================================================================
# Functions
#==============================================================================

log_info() {
    echo "[INFO] $1"
}

log_error() {
    echo "[ERROR] $1" >&2
}

check_dependencies() {
    log_info "Checking dependencies..."
    
    for cmd in wget tar cpio gzip; do
        if ! command -v "$cmd" &> /dev/null; then
            log_error "Missing dependency: $cmd"
            exit 1
        fi
    done
    
    if ! command -v "${CROSS_COMPILE}gcc" &> /dev/null; then
        log_error "Cross-compiler not found: ${CROSS_COMPILE}gcc"
        exit 1
    fi
    
    log_info "Dependencies OK"
}

create_directory_structure() {
    log_info "Creating directory structure..."
    
    mkdir -p "$WORK_DIR/initramfs"
    cd "$WORK_DIR/initramfs"
    
    # Create standard directories
    mkdir -p bin sbin etc proc sys dev tmp mnt/root lib lib64 run var/run
    
    # Create necessary files
    touch etc/passwd etc/group etc/shadow
    
    # Minimal /etc/passwd and /etc/group
    echo "root:x:0:0:root:/root:/bin/sh" > etc/passwd
    echo "root:x:0:" > etc/group
    
    log_info "Directory structure created"
}

download_busybox() {
    log_info "Downloading BusyBox ${BUSYBOX_VER}..."
    
    cd "$WORK_DIR"
    
    if [ -f "busybox-${BUSYBOX_VER}.tar.bz2" ]; then
        log_info "BusyBox archive already exists"
    else
        wget -q "$BUSYBOX_URL"
    fi
    
    if [ -d "busybox-${BUSYBOX_VER}" ]; then
        log_info "BusyBox source already extracted"
    else
        tar xf "busybox-${BUSYBOX_VER}.tar.bz2"
    fi
}

build_busybox() {
    log_info "Building BusyBox (static)..."
    
    cd "$WORK_DIR/busybox-${BUSYBOX_VER}"
    
    # Clean previous build
    make distclean 2>/dev/null || true
    
    # Configure
    make ARCH="$ARCH" CROSS_COMPILE="$CROSS_COMPILE" defconfig
    
    # Enable static linking
    sed -i 's/# CONFIG_STATIC is not set/CONFIG_STATIC=y/' .config
    
    # Disable some problematic options for minimal build
    sed -i 's/CONFIG_FEATURE_HAVE_RPC=y/# CONFIG_FEATURE_HAVE_RPC is not set/' .config
    sed -i 's/CONFIG_FEATURE_INETD_RPC=y/# CONFIG_FEATURE_INETD_RPC is not set/' .config
    
    # Build
    make ARCH="$ARCH" CROSS_COMPILE="$CROSS_COMPILE" -j$(nproc)
    
    # Verify static linking
    if ! file busybox | grep -q "statically linked"; then
        log_error "BusyBox is not statically linked!"
        exit 1
    fi
    
    log_info "BusyBox built successfully"
}

install_busybox() {
    log_info "Installing BusyBox to initramfs..."
    
    cd "$WORK_DIR/busybox-${BUSYBOX_VER}"
    
    # Install to initramfs
    make ARCH="$ARCH" CROSS_COMPILE="$CROSS_COMPILE" \
         CONFIG_PREFIX="$WORK_DIR/initramfs" install
    
    log_info "BusyBox installed"
}

create_init_script() {
    log_info "Creating init script..."
    
    cat > "$WORK_DIR/initramfs/init" << 'INIT_SCRIPT'
#!/bin/sh
#
# /init - Initramfs init script
#
# This script is executed as PID 1 when the kernel boots with initramfs.
# It sets up the minimal environment and optionally switches to the real root.
#

# Mount essential filesystems
mount -t proc proc /proc
mount -t sysfs sysfs /sys
mount -t devtmpfs devtmpfs /dev

# Create additional device nodes if devtmpfs didn't
mknod -m 666 /dev/null c 1 3 2>/dev/null
mknod -m 666 /dev/zero c 1 5 2>/dev/null
mknod -m 666 /dev/tty c 5 0 2>/dev/null

# Make output visible
exec 0</dev/console
exec 1>/dev/console
exec 2>/dev/console

# Print banner
echo ""
echo "================================================"
echo "       Initramfs Init Script"
echo "================================================"
echo ""

# Show BusyBox version
echo "BusyBox version:"
busybox --version | head -1
echo ""

# Parse kernel command line
ROOT=""
INIT="/sbin/init"
RESCUE=""

for param in $(cat /proc/cmdline); do
    case "$param" in
        root=*)
            ROOT="${param#root=}"
            ;;
        init=*)
            INIT="${param#init=}"
            ;;
        rescue|single|emergency)
            RESCUE="yes"
            ;;
    esac
done

echo "Parsed boot parameters:"
echo "  root=$ROOT"
echo "  init=$INIT"
echo "  rescue=$RESCUE"
echo ""

# Rescue mode - just drop to shell
if [ -n "$RESCUE" ]; then
    echo "Rescue mode requested, starting shell..."
    exec /bin/sh
fi

# If no root specified, stay in initramfs
if [ -z "$ROOT" ]; then
    echo "No root= parameter specified."
    echo "Starting initramfs shell..."
    echo "Available commands: $(busybox --list | tr '\n' ' ')"
    echo ""
    exec /bin/sh
fi

# Wait for root device
echo "Waiting for root device: $ROOT"
TIMEOUT=30
while [ ! -e "$ROOT" ] && [ $TIMEOUT -gt 0 ]; do
    echo "  Waiting... ($TIMEOUT seconds remaining)"
    sleep 1
    TIMEOUT=$((TIMEOUT - 1))
done

if [ ! -e "$ROOT" ]; then
    echo ""
    echo "ERROR: Root device $ROOT not found!"
    echo ""
    echo "Available block devices:"
    ls -la /dev/mmc* /dev/sd* /dev/nvme* 2>/dev/null || echo "  (none found)"
    echo ""
    echo "Contents of /proc/partitions:"
    cat /proc/partitions
    echo ""
    echo "Dropping to rescue shell..."
    exec /bin/sh
fi

# Mount root filesystem
echo "Mounting root filesystem..."
mount -o ro "$ROOT" /mnt/root

if [ $? -ne 0 ]; then
    echo ""
    echo "ERROR: Failed to mount root filesystem!"
    echo ""
    echo "Filesystem type may be wrong. Try:"
    echo "  mount -t ext4 $ROOT /mnt/root"
    echo "  mount -t vfat $ROOT /mnt/root"
    echo ""
    echo "Dropping to rescue shell..."
    exec /bin/sh
fi

echo "Root filesystem mounted successfully"

# Verify init exists
if [ ! -x "/mnt/root${INIT}" ]; then
    echo ""
    echo "ERROR: Init binary not found or not executable: ${INIT}"
    echo ""
    echo "Contents of /mnt/root/sbin/:"
    ls -la /mnt/root/sbin/ 2>/dev/null || echo "  (empty or not found)"
    echo ""
    echo "Dropping to rescue shell..."
    exec /bin/sh
fi

# Prepare for switch_root
echo ""
echo "Switching to real root filesystem..."
echo ""

# Unmount virtual filesystems
umount /proc /sys /dev 2>/dev/null

# Switch to real root and execute real init
exec switch_root /mnt/root "$INIT"

# If we get here, something went wrong
echo "ERROR: switch_root failed!"
mount -t proc proc /proc
mount -t sysfs sysfs /sys
mount -t devtmpfs devtmpfs /dev
exec /bin/sh
INIT_SCRIPT

    chmod +x "$WORK_DIR/initramfs/init"
    
    log_info "Init script created"
}

create_device_nodes() {
    log_info "Creating device nodes..."
    
    cd "$WORK_DIR/initramfs/dev"
    
    # Create essential device nodes
    # Note: This requires root privileges
    if [ "$(id -u)" = "0" ]; then
        mknod -m 666 null c 1 3
        mknod -m 666 zero c 1 5
        mknod -m 666 tty c 5 0
        mknod -m 600 console c 5 1
        mknod -m 666 ptmx c 5 2
        mknod -m 666 random c 1 8
        mknod -m 666 urandom c 1 9
        log_info "Device nodes created"
    else
        log_info "Not running as root, skipping device node creation"
        log_info "The kernel's devtmpfs will create them at boot"
    fi
}

create_cpio_archive() {
    log_info "Creating cpio archive..."
    
    cd "$WORK_DIR/initramfs"
    
    # Create cpio archive
    find . -print0 | cpio --null -ov --format=newc 2>/dev/null | gzip -9 > "$OUTPUT"
    
    log_info "Initramfs created: $OUTPUT"
    ls -lh "$OUTPUT"
}

print_usage_instructions() {
    echo ""
    echo "=============================================="
    echo "  Initramfs Creation Complete"
    echo "=============================================="
    echo ""
    echo "Output file: $OUTPUT"
    echo ""
    echo "To boot with this initramfs in U-Boot:"
    echo ""
    echo "  => load mmc 0:1 \${loadaddr} zImage"
    echo "  => load mmc 0:1 \${fdt_addr} board.dtb"
    echo "  => load mmc 0:1 \${ramdisk_addr} $(basename $OUTPUT)"
    echo "  => setenv bootargs console=ttyS0,115200 rdinit=/init"
    echo "  => bootz \${loadaddr} \${ramdisk_addr}:\${filesize} \${fdt_addr}"
    echo ""
    echo "To mount real root filesystem, add root= parameter:"
    echo "  => setenv bootargs console=ttyS0,115200 root=/dev/mmcblk0p2 rdinit=/init"
    echo ""
    echo "For rescue shell, add 'rescue' to bootargs:"
    echo "  => setenv bootargs console=ttyS0,115200 rescue"
    echo ""
}

#==============================================================================
# Main
#==============================================================================

echo ""
echo "=============================================="
echo "  Initramfs Creation Script"
echo "=============================================="
echo "  Architecture: $ARCH"
echo "  Cross-compiler: $CROSS_COMPILE"
echo "  BusyBox version: $BUSYBOX_VER"
echo "  Work directory: $WORK_DIR"
echo "  Output file: $OUTPUT"
echo "=============================================="
echo ""

check_dependencies
create_directory_structure
download_busybox
build_busybox
install_busybox
create_init_script
create_device_nodes
create_cpio_archive
print_usage_instructions

log_info "Done!"
