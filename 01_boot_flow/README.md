# Lab 01: Understanding the Boot Flow

> ⚠️ **Auto-Generated Content**: This document was generated by AI. Verify all commands before running on real hardware.

A hands-on exploration of the embedded Linux boot process from power-on to userspace using the **BeagleBone Black Rev. C**.

## Lab Objectives

By the end of this lab, you will be able to:

1. Identify all boot stages on a Raspberry Pi / BeagleBone
2. Observe boot stage transitions via serial console
3. Understand the purpose of each boot component
4. Measure boot time for each stage
5. Correlate boot messages with boot stages

## Prerequisites

### Required Hardware
- **BeagleBone Black Rev. C** (AM335x Cortex-A8, 512MB DDR3)
- **8GB microSD Card** (Class 10 recommended)
- **5V / 3A Power Supply** (barrel jack - USB may be insufficient)
- **USB Programming Cable** (Mini-USB) - provides serial console via /dev/ttyACM0
- **Ethernet Cable** (for later labs)
- Host computer with Linux (Ubuntu 20.04/22.04/24.04 recommended)

> **Note**: BeagleBone Black has a built-in USB-to-Serial converter. No external UART adapter needed!

## Hardware Setup

### BeagleBone Black Serial Console

BeagleBone Black has a **built-in FTDI USB-to-Serial chip**. Simply connect the USB programming cable (Mini-USB port near the Ethernet jack) to your host computer.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    BEAGLEBONE BLACK CONNECTIONS                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌───────────────────────────────────────────────────────────────────┐     │
│   │                      BeagleBone Black Rev. C                      │     │
│   │                                                                   │     │
│   │   ┌──────┐                                         ┌──────────┐   │     │
│   │   │ SD   │  8GB microSD                            │ Ethernet │   │     │
│   │   │ Slot │  (boot media)                           │   Port   │   │     │
│   │   └──────┘                                         └──────────┘   │     │
│   │                                                                   │     │
│   │   ┌──────────┐     ┌──────┐     ┌──────┐     ┌──────────────┐    │     │
│   │   │ USB Host │     │ BOOT │     │ PWR  │     │   5V Barrel  │    │     │
│   │   │ Type-A   │     │ Btn  │     │ LED  │     │   Jack (5V/3A)│    │     │
│   │   └──────────┘     └──────┘     └──────┘     └──────────────┘    │     │
│   │                        ↑                             ↑           │     │
│   │                        │                             │           │     │
│   │               Hold during power-on           USE THIS FOR POWER  │     │
│   │               to boot from SD card                               │     │
│   │                                                                   │     │
│   │   ┌──────────────┐                           ┌──────────────┐    │     │
│   │   │   Mini-USB   │◄── Serial Console         │  Micro-HDMI  │    │     │
│   │   │ (Programming)│    /dev/ttyACM0           │  (optional)  │    │     │
│   │   └──────────────┘                           └──────────────┘    │     │
│   │                                                                   │     │
│   └───────────────────────────────────────────────────────────────────┘     │
│                                                                             │
│   BOOT MODES:                                                               │
│   • eMMC Boot (default): Power on normally → boots from onboard eMMC       │
│   • SD Card Boot: Hold BOOT button while applying power → boots from SD    │
│                                                                             │
│   POWER NOTES:                                                              │
│   • Use 5V/3A barrel jack for reliable power (NOT USB!)                     │
│   • USB provides serial only when barrel jack is used                       │
│   • If using USB power alone, current may be insufficient for stability     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Alternative: External UART Adapter (J1 Header)

If you prefer an external USB-to-UART adapter, use the J1 debug header:

```
│  BeagleBone Black J1 Header:                                                │
│  ┌─────────────────────────────┐                                            │
│  │  Pin 1: GND                 │  ← Connect to GND on adapter               │
│  │  Pin 4: RX                  │  ← Connect to TX on adapter                │
│  │  Pin 5: TX                  │  ← Connect to RX on adapter                │
│  └─────────────────────────────┘                                            │
│                                                                             │
│  CAUTION: Use 3.3V logic level adapters only! 5V damages the board!        │
```

### Opening Serial Console

```bash
# Connect BeagleBone Black via USB programming cable
# The BBB appears as /dev/ttyACM0

# Check device is recognized
dmesg | grep tty
# Look for: cdc_acm 1-1:1.0: ttyACM0: USB ACM device

# Option 1: picocom (recommended)
picocom -b 115200 /dev/ttyACM0

# Option 2: minicom
minicom -D /dev/ttyACM0 -b 115200

# Option 3: screen
screen /dev/ttyACM0 115200

# Option 4: cu
sudo cu -l /dev/ttyACM0 -s 115200

# Permissions issue? Add yourself to dialout group:
sudo usermod -a -G dialout $USER
# Then logout and login again (or use: newgrp dialout)
```

---

## Exercise 1: Observe Complete Boot Sequence

### Task
Power on your board while watching serial console output. Identify each boot stage.

### Procedure

1. Connect serial console and start terminal software
2. Have a working SD card inserted
3. Power cycle the board
4. Observe and record the output

### Expected Output (BeagleBone Black)

```
[Stage 1: AM335x Boot ROM - No visible output]
(ROM reads boot pins, checks boot devices: eMMC, SD, UART, USB)

[Stage 2: SPL/MLO - Secondary Program Loader]
U-Boot SPL 2024.01 (Jan 01 2024 - 00:00:00 +0000)
Trying to boot from MMC1

[Stage 3: U-Boot - Full Bootloader]
U-Boot 2024.01 (Jan 01 2024 - 00:00:00 +0000)

CPU  : AM335X-GP rev 2.1
Model: TI AM335x BeagleBone Black
DRAM:  512 MiB
WDT:   Started with servicing (60s timeout)
NAND:  0 MiB
MMC:   OMAP SD/MMC: 0, OMAP SD/MMC: 1
Loading Environment from FAT... OK
Net:   eth0: ethernet@4a100000
Hit any key to stop autoboot:  3

[Stage 4: Linux Kernel]
Starting kernel ...

[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 6.6.20 (user@host) (arm-linux-gnueabihf-gcc...)
[    0.000000] CPU: ARMv7 Processor [413fc082] revision 2 (ARMv7), cr=10c5387d
[    0.000000] Machine model: TI AM335x BeagleBone Black
...
[    1.234567] VFS: Mounted root (ext4 filesystem) readonly on device 179:2.

[Stage 5: Init/Userspace]
[    1.567890] Run /sbin/init as init process
[    2.345678] systemd[1]: System is starting...

Debian GNU/Linux 11 beaglebone ttyS0

beaglebone login:
```

### Questions to Answer

1. At what point do you first see output? Why might earlier stages be silent?
2. How can you identify the transition from U-Boot to kernel?
3. What does "Hit any key to stop autoboot" mean?
4. What is the first kernel message timestamp?
5. What init system is being used (systemd, SysV init, BusyBox)?

---

## Exercise 2: Interrupt Boot at U-Boot

### Task
Stop the autoboot timer and explore U-Boot commands.

### Procedure

1. Boot the board and watch for "Hit any key to stop autoboot"
2. Press any key (Enter, Space, etc.) before timer expires
3. You should see the U-Boot prompt: `=>`

### Essential U-Boot Commands

```bash
# Get help
=> help
=> help <command>

# Print environment variables
=> printenv
=> printenv bootcmd

# Print board info
=> bdinfo

# Print system info
=> version

# Memory commands
=> md.b 0x80000000 100      # Memory display (bytes)
=> md.w 0x80000000 100      # Memory display (words)

# Storage commands
=> mmc info                  # MMC card info
=> mmc part                  # List partitions
=> fatls mmc 0:1             # List files on FAT partition

# Network (if available)
=> dhcp
=> ping 192.168.1.1

# Boot
=> boot                      # Execute bootcmd
=> run bootcmd               # Same as boot
=> reset                     # Reboot
```

### Document Your Findings

Record the output of these commands:
- `printenv` - Note bootcmd and bootargs
- `bdinfo` - Note DRAM size and addresses
- `mmc part` - Note partition layout
- `fatls mmc 0:1` - Note boot files present

---

## Exercise 3: Measure Boot Times

### Task
Measure the time spent in each boot stage.

### Procedure

1. Add timestamps to your terminal output
2. Power cycle and capture boot log
3. Calculate time differences

### Using Screen with Timestamps

```bash
# Create a log file with timestamps
screen -L -Logfile boot_log.txt /dev/ttyUSB0 115200

# In another terminal, add timestamps to the log
while true; do
    echo "$(date '+%H:%M:%S.%3N') $(cat boot_log.txt | tail -1)"
done
```

### Using Script Command

```bash
# Record with timestamps using script
script -c "picocom -b 115200 /dev/ttyUSB0" boot_log.txt

# Add timestamps post-processing
ts '%H:%M:%S' < boot_log.txt > boot_log_timestamped.txt
```

### Kernel Boot Timing (printk timestamps)

```bash
# Kernel already includes timestamps [    0.000000]
# Extract timing milestones:

# First kernel message
grep "Booting Linux" boot_log.txt

# Memory initialization done
grep "Memory:" boot_log.txt

# Root filesystem mounted
grep "VFS: Mounted root" boot_log.txt

# Init starts
grep "Run /sbin/init" boot_log.txt

# Login prompt
grep "login:" boot_log.txt
```

### Create a Boot Timeline

Fill in this table with your measurements:

| Stage | Start Time | End Time | Duration |
|-------|------------|----------|----------|
| Power On → First Output | 0.000s | | |
| SPL | | | |
| U-Boot | | | |
| Kernel Start | | | |
| Kernel → Root Mount | | | |
| Init → Login | | | |
| **Total** | 0.000s | | |

---

## Exercise 4: Examine Boot Components on SD Card

### Task
Mount the SD card on your host and examine the boot components.

### Procedure

```bash
# Insert SD card into host computer
lsblk
# Identify device (e.g., /dev/sdb)

# Mount boot partition (FAT32)
sudo mkdir -p /mnt/boot
sudo mount /dev/sdb1 /mnt/boot

# List boot files
ls -la /mnt/boot

# Raspberry Pi typical contents:
# BeagleBone Black boot partition contents:
# MLO            - SPL (Secondary Program Loader / MMC Loader)
# u-boot.img     - U-Boot proper
# zImage         - Linux kernel
# am335x-boneblack.dtb - Device tree blob
# uEnv.txt       - U-Boot environment overrides (optional)
```

### Examine File Sizes

```bash
# Understanding sizes helps understand constraints
du -h /mnt/boot/*

# Typical sizes:
# SPL (MLO):      50-100 KB (must fit in internal SRAM)
# U-Boot:         400-800 KB
# Kernel:         5-10 MB
# DTB:            20-50 KB
# initramfs:      2-50 MB (if present)
```

### Examine config.txt (Raspberry Pi)

```bash
cat /mnt/boot/config.txt

# Look for these important settings:
# enable_uart=1      - Enable UART for serial console
# kernel=u-boot.bin  - Use U-Boot as kernel (for U-Boot boot)
# dtoverlay=...      - Device tree overlays
```

---

## Exercise 5: Modify Boot Behavior

### Task
Change boot parameters and observe the effects.

### Option A: Change Console Verbosity

```bash
# At U-Boot prompt, modify bootargs
=> printenv bootargs
# Record current value

# Add verbose kernel output
=> setenv bootargs ${bootargs} loglevel=8 debug

# Boot and observe more messages
=> boot

# After testing, restore original:
=> setenv bootargs <original_value>
=> saveenv
```

### Option B: Add Boot Delay

```bash
# At U-Boot prompt
=> setenv bootdelay 10      # 10 second delay
=> saveenv
=> reset

# Now you have 10 seconds to interrupt boot
```

### Option C: Boot to Shell

```bash
# Boot directly to shell instead of init
=> setenv bootargs ${bootargs} init=/bin/sh
=> boot

# You'll get a root shell before init runs
# Type 'exec /sbin/init' to continue normal boot
```

---

## Lab Deliverables

Create a lab report containing:

1. **Boot log capture** - Complete boot output from power-on to login
2. **Boot stage identification** - Annotated log showing each stage
3. **Boot timeline** - Table with measured boot times
4. **SD card analysis** - List of boot components and sizes
5. **U-Boot exploration** - Output of key commands
6. **Answers to questions** - From Exercise 1

---

## Troubleshooting

### No Serial Output

1. **Check USB cable**: Use the Mini-USB programming port (near Ethernet)
2. **Check device**: Look for /dev/ttyACM0 (built-in USB-serial)
3. **Verify baud rate**: Should be 115200
4. **Check permissions**: `sudo usermod -a -G dialout $USER`
5. **Check boot source**: Hold BOOT button to force SD card boot

### Garbage Characters

1. Wrong baud rate - should be 115200 (not 9600)
2. Wrong serial settings - should be 8N1 (8 bits, no parity, 1 stop)
3. Electrical noise - use shorter cables

### U-Boot Doesn't Stop

1. Press key earlier (before countdown appears)
2. Hold key during power-on
3. Check if `bootdelay` is 0 (instant boot)
4. Try pressing 'Enter' rapidly during boot

### Board Doesn't Boot

1. **Power**: Use 5V/3A barrel jack (not USB power)
2. **SD card boot**: Hold BOOT button while applying power
3. **SD card format**: Must be FAT32 for boot partition
4. **MLO placement**: MLO must be first file on FAT partition
5. **Check LEDs**: Power LED should be on, heartbeat LED should blink

---

## What You Learned

After completing this lab, you understand:

1. ✅ The complete boot sequence from power-on to login
2. ✅ How to connect and use serial console
3. ✅ How to interrupt boot and access U-Boot
4. ✅ Basic U-Boot commands for debugging
5. ✅ What files are involved in booting
6. ✅ How to measure boot time
7. ✅ How to modify boot behavior via bootargs

---

## Next Lab

Continue to [Lab 02: U-Boot Bootloader](../02_uboot/README.md) to learn how to build and customize U-Boot.
