# Lab 02: U-Boot Bootloader

> ⚠️ **Auto-Generated Content**: This document was generated by AI. Verify all commands before running on real hardware.

A hands-on lab for building, configuring, and extending the U-Boot bootloader for **BeagleBone Black Rev. C**.

## Lab Objectives

By the end of this lab, you will be able to:

1. Understand the SPL/U-Boot two-stage bootloader
2. Download and build U-Boot from source for BeagleBone Black
3. Configure U-Boot for your target board
4. Set up persistent environment storage
5. Create custom U-Boot commands
6. Use U-Boot for network and storage boot

## Prerequisites

- Completed [Lab 01: Boot Flow](../01_boot_flow/README.md)
- **BeagleBone Black Rev. C** with accessories (8GB SD, 5V/3A PSU, USB cable)
- Cross-compilation toolchain: `arm-linux-gnueabihf-`
- Target board with serial console access
- Read: [SPL Guide](../docs/spl_guide.md) and [SPL/U-Boot Relationship](../docs/uboot_spl_relationship.md)

## Lab Structure

```
02_uboot/
├── README.md              ← This file
├── build_uboot.sh         ← U-Boot build script
├── env_sdcard/            ← Environment persistence lab
│   ├── README.md          ← Environment lab instructions
│   └── uboot_env_config.txt   ← Example environment
└── custom_cmd/            ← Custom command lab
    ├── README.md          ← Custom command instructions
    ├── cmd_hello.c        ← Example custom command
    └── Makefile.patch     ← Build system integration
```

---

## Part 1: Building U-Boot for BeagleBone Black

### Understanding What We're Building

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              BUILD OUTPUT FOR BEAGLEBONE BLACK                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   ┌─────────────┐    ┌────────────────┐                                   │
│   │     MLO     │    │   u-boot.img   │                                   │
│   │   (~100KB)  │    │    (~500KB)    │                                   │
│   └─────────────┘    └────────────────┘                                   │
│        │                   │                                            │
│        │                   │                                            │
│        v                   v                                            │
│   SPL (Stage 1)      U-Boot (Stage 2)                                   │
│   - Loaded by ROM    - Loaded by SPL                                    │
│   - Runs from SRAM   - Runs from DDR                                    │
│   - Inits DDR RAM    - Full bootloader                                  │
│   - Loads U-Boot     - Loads kernel                                     │
│                                                                         │
│   BOTH files are needed to boot BeagleBone Black!                       │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Step 1: Get the Source Code

```bash
# Clone U-Boot repository
git clone https://source.denx.de/u-boot/u-boot.git
cd u-boot

# List available tags/versions
git tag | grep v2024

# Checkout stable version
git checkout v2024.01 -b lab-2024.01

# View BeagleBone Black configuration
ls configs/ | grep am335x
# am335x_evm_defconfig  ← This is for BeagleBone Black!
```

### Step 2: Configure for BeagleBone Black

```bash
# Set up cross-compiler (ARM 32-bit for AM335x)
export ARCH=arm
export CROSS_COMPILE=arm-linux-gnueabihf-

# Verify cross-compiler is available
${CROSS_COMPILE}gcc --version

# Apply BeagleBone Black defconfig
make am335x_evm_defconfig

# This creates .config with settings for:
# - AM335x SoC
# - 512MB DDR3 RAM
# - SPL (MLO) generation
# - MMC/SD boot support
# - Ethernet support
```

### Step 3: Customize Configuration (Optional)

```bash
# Open menuconfig for advanced configuration
make menuconfig

# Key options to explore:
# - Boot options
#   - Autoboot delay (CONFIG_BOOTDELAY)
#   - Default boot command
# - Environment
#   - Environment storage location
#   - Environment size
# - Device Drivers
#   - MMC/SD support
#   - USB support
#   - Network support
# - Command line interface
#   - Available commands
```

### Step 4: Build

```bash
# Build U-Boot (generates both SPL/MLO and U-Boot)
make -j$(nproc)

# BeagleBone Black outputs:
# - MLO              : SPL with TI header (REQUIRED for boot)
# - u-boot.img       : Full U-Boot with header (REQUIRED for boot)
# - u-boot.bin       : Raw U-Boot binary (not used directly)
# - u-boot           : ELF format (for debugging)

# Check sizes
ls -lh MLO u-boot.img
# MLO:        ~100KB (must fit in 128KB SRAM)
# u-boot.img: ~500KB (runs from DDR)
```

### Step 5: Deploy to SD Card

```bash
# Identify your SD card device (BE CAREFUL!)
lsblk
# Usually /dev/sdb or /dev/mmcblk0

# Mount SD card boot partition (FAT32)
sudo mount /dev/sdb1 /mnt

# Copy BOTH files (order doesn't matter here, but MLO must exist first on fresh FAT)
sudo cp MLO /mnt/
sudo cp u-boot.img /mnt/

# Verify
ls -la /mnt/

# Unmount
sudo sync
sudo umount /mnt

# Insert SD card in BeagleBone Black
# Hold BOOT button, apply power, release after 2 seconds
# Watch serial console for new U-Boot version!
```

---

## Part 2: Environment Configuration

The U-Boot environment contains variables that control boot behavior.

### Understanding Environment Storage

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    U-BOOT ENVIRONMENT STORAGE                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Storage Options:                                                           │
│                                                                             │
│  1. Embedded in U-Boot binary (default for some boards)                     │
│     - Cannot be modified permanently                                        │
│     - Good for production systems                                           │
│                                                                             │
│  2. MMC/SD card (CONFIG_ENV_IS_IN_MMC)                                      │
│     - Stored in dedicated partition or raw sector                           │
│     - Survives U-Boot updates                                               │
│     - Common for development                                                │
│                                                                             │
│  3. FAT filesystem (CONFIG_ENV_IS_IN_FAT)                                   │
│     - Stored as file on FAT partition                                       │
│     - Easy to backup/restore                                                │
│     - Good for development                                                  │
│                                                                             │
│  4. SPI Flash (CONFIG_ENV_IS_IN_SPI_FLASH)                                  │
│     - Common for production                                                 │
│     - Fast access                                                           │
│                                                                             │
│  5. NAND Flash (CONFIG_ENV_IS_IN_NAND)                                      │
│     - For NAND-based systems                                                │
│     - Requires bad block handling                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Exercise: Set Up Persistent Environment

See [env_sdcard/README.md](env_sdcard/README.md) for detailed instructions.

Quick overview:

```bash
# At U-Boot prompt, view current environment
=> printenv

# Modify a variable
=> setenv bootdelay 5

# Save to persistent storage
=> saveenv
Saving Environment to MMC... Writing to MMC(0)... OK

# Reset and verify it persists
=> reset
```

### Common Environment Variables

```bash
# Boot control
bootcmd        # Command(s) to run at boot
bootdelay      # Seconds to wait before autoboot
bootargs       # Arguments passed to Linux kernel

# Memory addresses
loadaddr       # Default address to load files
fdt_addr       # Address for device tree
kernel_addr    # Address for kernel

# Network
ipaddr         # Board's IP address
serverip       # TFTP server IP
netmask        # Network mask
gatewayip      # Gateway IP

# Device/file settings
bootpart       # Boot partition
fdtfile        # Device tree file name
```

---

## Part 3: Network Boot

U-Boot can boot over the network, useful for development.

### Configure Network

```bash
# Set IP addresses
=> setenv ipaddr 192.168.1.50
=> setenv serverip 192.168.1.100
=> setenv netmask 255.255.255.0
=> setenv gatewayip 192.168.1.1

# Test connectivity
=> ping ${serverip}
Using ethernet@... device
host 192.168.1.100 is alive
```

### TFTP Boot

```bash
# On host: Start TFTP server, copy files to /tftpboot/
sudo cp zImage /tftpboot/
sudo cp board.dtb /tftpboot/

# On target: Download and boot
=> tftp ${loadaddr} zImage
=> tftp ${fdt_addr} board.dtb
=> setenv bootargs console=ttyS0,115200 root=/dev/nfs nfsroot=${serverip}:/export/rootfs ip=dhcp
=> bootz ${loadaddr} - ${fdt_addr}
```

### Create Network Boot Script

```bash
# Define network boot commands
=> setenv netboot 'tftp ${loadaddr} zImage; tftp ${fdt_addr} ${fdtfile}; bootz ${loadaddr} - ${fdt_addr}'

# Set bootargs for NFS root
=> setenv netargs 'setenv bootargs console=ttyS0,115200 root=/dev/nfs nfsroot=${serverip}:/rootfs ip=dhcp'

# Combine them
=> setenv bootcmd 'run netargs; run netboot'

# Save for persistent network boot
=> saveenv
```

---

## Part 4: Custom U-Boot Commands

Learn to extend U-Boot with your own commands.

See [custom_cmd/README.md](custom_cmd/README.md) for detailed instructions.

### Overview

```c
// Custom command structure
#include <command.h>

static int do_hello(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
{
    printf("Hello from custom U-Boot command!\n");
    if (argc > 1)
        printf("Argument: %s\n", argv[1]);
    return 0;
}

U_BOOT_CMD(
    hello, 2, 0, do_hello,
    "say hello",
    "[message] - print hello message"
);
```

---

## Part 5: Boot Scripting

U-Boot supports powerful scripting for complex boot scenarios.

### Simple Boot Script

```bash
# Create a script file (boot.cmd)
cat << 'EOF' > boot.cmd
echo "=== Custom Boot Script ==="
setenv bootargs console=ttyS0,115200 root=/dev/mmcblk0p2 rootwait rw

if load mmc 0:1 ${loadaddr} zImage; then
    echo "Kernel loaded successfully"
else
    echo "Failed to load kernel!"
    exit 1
fi

if load mmc 0:1 ${fdt_addr} ${fdtfile}; then
    echo "DTB loaded successfully"
else
    echo "Failed to load DTB!"
    exit 1
fi

echo "Booting Linux..."
bootz ${loadaddr} - ${fdt_addr}
EOF

# Compile to U-Boot script format
mkimage -C none -A arm -T script -d boot.cmd boot.scr

# Copy to SD card
sudo cp boot.scr /mnt/boot/
```

### Advanced: Fallback Boot Script

```bash
cat << 'EOF' > boot.cmd
echo "=== Multi-Boot Script ==="

# Try SD card first
if load mmc 0:1 ${loadaddr} zImage; then
    echo "Booting from SD card..."
    load mmc 0:1 ${fdt_addr} ${fdtfile}
    setenv bootargs console=ttyS0,115200 root=/dev/mmcblk0p2 rootwait rw
    bootz ${loadaddr} - ${fdt_addr}
fi

# Fallback to network
echo "SD boot failed, trying network..."
dhcp
if tftp ${loadaddr} zImage; then
    tftp ${fdt_addr} board.dtb
    setenv bootargs console=ttyS0,115200 root=/dev/nfs nfsroot=${serverip}:/rootfs ip=dhcp
    bootz ${loadaddr} - ${fdt_addr}
fi

# If all else fails
echo "All boot methods failed!"
EOF
```

---

## Lab Exercises

### Exercise 1: Build U-Boot for Your Board

1. Clone U-Boot source
2. Configure for your target
3. Build and deploy
4. Verify it boots
5. Compare version string with original

### Exercise 2: Customize Boot Delay and Message

1. Change bootdelay to 10 seconds
2. Add a custom boot message
3. Save environment
4. Verify persistence after reset

### Exercise 3: Create Network Boot Configuration

1. Set up TFTP server on host
2. Configure U-Boot network settings
3. Create netboot command sequence
4. Successfully boot via TFTP

### Exercise 4: Implement Custom Command

1. Follow [custom_cmd/README.md](custom_cmd/README.md)
2. Add a command that displays board info
3. Rebuild U-Boot
4. Test your command

### Exercise 5: Create Multi-Boot Script

1. Create boot.scr that tries multiple sources
2. Add timeout and fallback logic
3. Test by removing kernel from SD card

---

## Troubleshooting

### Build Errors

```bash
# Missing toolchain
arm-linux-gnueabihf-gcc: command not found
# Solution: Install cross-compiler or set CROSS_COMPILE correctly

# Missing dependencies
fatal error: openssl/evp.h: No such file or directory
# Solution: sudo apt-get install libssl-dev

# Wrong architecture
arch/arm64/Makefile:27: ld does not support --fix-cortex-a53-843419
# Solution: Use correct cross-compiler for architecture
```

### Environment Not Saving

```bash
# Check environment storage location
=> printenv
# Look for: Environment size: xxx/xxx bytes

# If "Saving Environment... failed"
# Check CONFIG_ENV_IS_IN_* in menuconfig
# Verify storage device is writable
```

### Network Issues

```bash
# No network device found
=> dhcp
No ethernet found.
# Check network driver is enabled in config

# Ping fails
=> ping 192.168.1.100
# Check cables, IP addresses, firewall
```

---

## What You Learned

After completing this lab, you understand:

1. ✅ How to obtain and build U-Boot from source
2. ✅ U-Boot configuration system (defconfig, menuconfig)
3. ✅ Environment variables and persistence
4. ✅ Network boot with TFTP
5. ✅ Boot scripting with boot.scr
6. ✅ Basics of extending U-Boot with custom commands

---

## Next Lab

Continue to [Lab 03: Linux Kernel](../03_kernel/README.md) to learn how to build and configure the Linux kernel.
